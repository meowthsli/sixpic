(define (linearize-and-cleanup cfg)

  (define bbs-vector (cfg->vector cfg))

  (define todo '())

  (define (add-todo bb)
    (set! todo (cons bb todo)))

  (define rev-code '())

  (define (emit instr)
    (set! rev-code (cons instr rev-code)))

  (define (movlw val)
    (emit (list 'movlw val)))
  (define (movwf adr)
    (emit (list 'movwf adr)))
  (define (movfw adr)
    (emit (list 'movfw adr)))
  (define (movff src dst)
    (emit (list 'movff src dst)))

  (define (clrf adr)
    (emit (list 'clrf adr)))
  (define (setf adr)
    (emit (list 'setf adr)))

  (define (incf adr)
    (emit (list 'incf adr)))
  (define (decf adr)
    (emit (list 'decf adr)))

  (define (addwf adr)
    (emit (list 'addwf adr)))
  (define (addwfc adr)
    (emit (list 'addwfc adr)))

  (define (subwf adr)
    (emit (list 'subwf adr)))
  (define (subwfb adr)
    (emit (list 'subwfb adr)))

  (define (mullw adr)
    (emit (list 'mullw adr)))
  (define (mulwf adr)
    (emit (list 'mulwf adr)))

  (define (andwf adr)
    (emit (list 'andwf adr)))
  (define (iorwf adr)
    (emit (list 'iorwf adr)))
  (define (xorwf adr)
    (emit (list 'xorwf adr)))

  (define (rlcf adr)
    (emit (list 'rlcf adr)))
  (define (rrcf adr)
    (emit (list 'rrcf adr)))

  (define (bcf adr bit)
    (emit (list 'bcf adr bit)))
  (define (bsf adr bit)
    (emit (list 'bsf adr bit)))
  (define (btg adr bit)
    (emit (list 'btg adr bit)))

  (define (comf adr)
    (emit (list 'comf adr)))

  (define (cpfseq adr)
    (emit (list 'cpfseq adr)))
  (define (cpfslt adr)
    (emit (list 'cpfslt adr)))
  (define (cpfsgt adr)
    (emit (list 'cpfsgt adr)))

  (define (bra label)
    (emit (list 'bra label)))

  (define (rcall label)
    (emit (list 'rcall label)))

  (define (return)
    (if (and #f (and (not (null? rev-code))
                     (eq? (caar rev-code) 'rcall)))
        (let ((label (cadar rev-code)))
          (set! rev-code (cdr rev-code))
          (bra label))
        (emit (list 'return))))

  (define (label lab)
    (if (and #f (and (not (null? rev-code))
                     (eq? (caar rev-code) 'bra)
                     (eq? (cadar rev-code) lab)))
        (begin
          (set! rev-code (cdr rev-code))
          (label lab))
        (emit (list 'label lab))))

  (define (sleep)
    (emit (list 'sleep)))

  (define (move-reg src dst)
    (cond ((= src dst))
          ((= src WREG)
           (movwf dst))
          ((= dst WREG)
           (movfw src))
          (else
           ;;         (movfw src)
           ;;         (movwf dst)
           ;; takes 2 cycles (as much as movfw src ; movwf dst), but takes
           ;; only 1 instruction
           (movff src dst))))

  (define (bb-linearize bb)
    (let ((label-num (bb-label-num bb)))
      (let ((bb (vector-ref bbs-vector label-num)))

        (define (move-lit n adr)
          (cond ((= n 0)
                 (clrf adr))
                ((= n #xff)
                 (setf adr))
                (else
                 (movlw n)
                 (movwf adr))))

        (define (dump-instr instr)
          (cond ((call-instr? instr)
                 (let* ((def-proc (call-instr-def-proc instr))
                        (entry (def-procedure-entry def-proc)))
                   (if (bb? entry)
                       (begin
                         (add-todo entry)
                         (let ((label (bb-label entry)))
                           (rcall label)))
                       (rcall entry))))
                ((return-instr? instr)
                 (return))
                (else
                 (let ((src1 (instr-src1 instr))
                       (src2 (instr-src2 instr))
                       (dst (instr-dst instr)))
                   (if (and (or (not (byte-cell? dst))
                                (byte-cell-adr dst))
                            (or (not (byte-cell? src1))
                                (byte-cell-adr src1))
                            (or (not (byte-cell? src2))
                                (byte-cell-adr src2)))

                       (case (instr-id instr)

                         ((move)
                          (if (byte-lit? src1)
                              (let ((n (byte-lit-val src1))
                                    (z (byte-cell-adr dst)))
                                (move-lit n z))
                              (let ((x (byte-cell-adr src1))
                                    (z (byte-cell-adr dst)))
                                (move-reg x z))))

                         ((add addc sub subb)
                          (if (byte-lit? src2)
                              (let ((n (byte-lit-val src2))
                                    (z (byte-cell-adr dst)))
                                (if (byte-lit? src1)
                                    (move-lit (byte-lit-val src1) z)
                                    (move-reg (byte-cell-adr src1) z))
                                (case (instr-id instr)
                                  ((add)  (cond ((= n 1)    (incf z))
                                                ((= n #xff) (decf z))
                                                (else       (movlw n)
                                                            (addwf z))))
                                  ((addc) (movlw n) (addwfc z))
                                  ((sub)  (cond ((= n 1)    (decf z))
                                                ((= n #xff) (incf z))
                                                (else       (movlw n)
                                                            (subwf z))))
                                  ((subb) (movlw n) (subwfb z))))
                              (let ((x (byte-cell-adr src1))
                                    (y (byte-cell-adr src2))
                                    (z (byte-cell-adr dst)))
                                (cond ((and (not (= x y))
                                            (= y z)
                                            (memq (instr-id instr)
                                                  '(add addc)))
                                       ;; since this basically swaps the
                                       ;; arguments, it can't be used for
                                       ;; subtraction
                                       (move-reg x WREG))
                                      ((and (not (= x y))
                                            (= y z))
                                       ;; for subtraction, preserves argument
                                       ;; order
                                       (move-reg y WREG)
                                       ;; this NEEDS to be done with movff, or
                                       ;; else wreg will get clobbered and this
                                       ;; won't work
                                       (move-reg x z))
                                      (else ;; TODO check if it could be merged with the previous case
                                       (move-reg x z)
                                       (move-reg y WREG)))
                                (case (instr-id instr)
                                  ((add)  (addwf z))
                                  ((addc) (addwfc z))
                                  ((sub)  (subwf z))
                                  ((subb) (subwfb z))
                                  (else   (error "..."))))))

                         ((mul) ; 8 by 8 multiplication
                          (if (byte-lit? src2)
                              ;; since multiplication is commutative, the
                              ;; arguments are set up so the second one will
                              ;; be a literal if the operator is applied on a
                              ;; literal and a variable
                              (let ((n (byte-lit-val src2)))
                                (if (byte-lit? src1)
                                    (movlw   (byte-lit-val src1))
                                    (move-reg (byte-cell-adr src1) WREG))
                                ;; literal multiplication
                                (mullw n))
                              (let ((x (byte-cell-adr src1))
                                    (y (byte-cell-adr src2)))
                                (move-reg x WREG)
                                (mulwf y))))

                         ((and ior xor)
                          ;; no instructions for bitwise operations involving
                          ;; literals exist on the PIC18
                          (let ((x (if (byte-lit? src1)
                                       (byte-lit-val src1)
                                       (byte-cell-adr src1)))
                                (y (if (byte-lit? src2)
                                       (byte-lit-val src2)
                                       (byte-cell-adr src2)))
                                (z (byte-cell-adr dst)))
                            (cond ((byte-lit? src1)
                                   (if (byte-lit? src2)
                                       (move-lit y z)
                                       (move-reg y z))
                                   (movlw x))
                                  ((and (not (= x y)) (= y z))
                                   (move-reg x WREG))
                                  (else
                                   (move-reg x z)
                                   (move-reg y WREG)))
                            (case (instr-id instr)
                              ((and) (andwf z))
                              ((ior) (iorwf z))
                              ((xor) (xorwf z))
                              (else (error "...")))))

                         ((shl shr)
                          (let ((x (if (byte-lit? src1)
                                       (byte-lit-val src1)
                                       (byte-cell-adr src1)))
                                (z (byte-cell-adr dst)))
                            (cond ((byte-lit? src1) (move-lit x z))
                                  ((not (= x z))    (move-reg x z)))
                            (case (instr-id instr)
                              ((shl) (rlcf z))
                              ((shr) (rrcf z)))))

                         ((set clear toggle)
                          ;; bit operations
                          (if (not (byte-lit? src2))
                              (error "bit offset must be a literal"))
                          (let ((x (byte-cell-adr src1))
                                (y (byte-lit-val src2)))
                            (case (instr-id instr)
                              ((set)    (bsf x y))
                              ((clear)  (bcf x y))
                              ((toggle) (btg x y)))))

                         ((not)
                          (let ((z (byte-cell-adr dst)))
                            (if (byte-lit? src1)
                                (move-lit (byte-lit-val  src1) z)
                                (move-reg (byte-cell-adr src1) z))
                            (comf z)))

                         ((goto)
                          (if (null? (bb-succs bb))
                              (error "I think you might have given me an empty source file."))
                          (let* ((succs (bb-succs bb))
                                 (dest (car succs)))
                            (bra (bb-label dest))
                            (add-todo dest)))
                         ((x==y x<y x>y)
                          (let* ((succs (bb-succs bb))
                                 (dest-true (car succs))
                                 (dest-false (cadr succs)))

                            (define (compare flip adr)
                              (case (instr-id instr)
                                ((x<y) (if flip (cpfsgt adr) (cpfslt adr)))
                                ((x>y) (if flip (cpfslt adr) (cpfsgt adr)))
                                (else (cpfseq adr)))
                              (bra (bb-label dest-false))
                              (bra (bb-label dest-true))
                              (add-todo dest-false)
                              (add-todo dest-true))

                            (cond ((byte-lit? src1)
                                   (let ((n (byte-lit-val src1))
                                         (y (byte-cell-adr src2)))
                                     (if #f #;(and (or (= n 0) (= n 1) (= n #xff))
                                         (eq? (instr-id instr) 'x==y))
                                     (special-compare-eq-lit n x)
                                     (begin
                                       (movlw n)
                                       (compare #t y)))))
                            ((byte-lit? src2)
                             (let ((x (byte-cell-adr src1))
                                   (n (byte-lit-val src2)))
                               (if #f #;(and (or (= n 0) (= n 1) (= n #xff))
                                   (eq? (instr-id instr) 'x==y))
                               (special-compare-eq-lit n x)
                               (begin
                                 (movlw n)
                                 (compare #f x)))))
                          (else
                           (let ((x (byte-cell-adr src1))
                                 (y (byte-cell-adr src2)))
                             (move-reg y WREG)
                             (compare #f x))))))
                   (else
                                        ;...
                    (emit (list (instr-id instr))))))))))

    (if bb
        (begin
          (vector-set! bbs-vector label-num #f)
          (label (bb-label bb))
          (for-each dump-instr (reverse (bb-rev-instrs bb)))
          (for-each add-todo (bb-succs bb)))))))

(let ((prog-label (asm-make-label 'PROG)))
  (rcall prog-label)
  (sleep)
  (label prog-label))

(add-todo (vector-ref bbs-vector 0))

(let loop ()
  (if (null? todo)
      (reverse rev-code)
      (let ((bb (car todo)))
        (set! todo (cdr todo))
        (bb-linearize bb)
        (loop)))))


(define (assembler-gen filename cfg)

  (define (gen instr)
    (case (car instr)
      ((movlw)
       (movlw (cadr instr)))
      ((movwf)
       (movwf (cadr instr)))
      ((movfw)
       (movf (cadr instr) 'w))
      ((movff)
       (movff (cadr instr) (caddr instr)))
      ((clrf)
       (clrf (cadr instr)))
      ((setf)
       (setf (cadr instr)))
      ((incf)
       (incf (cadr instr)))
      ((decf)
       (decf (cadr instr)))
      ((addwf)
       (addwf (cadr instr)))
      ((addwfc)
       (addwfc (cadr instr)))
      ((subwf)
       (subwf (cadr instr)))
      ((subwfb)
       (subwfb (cadr instr)))
      ((mullw)
       (mullw (cadr instr)))
      ((mulwf)
       (mulwf (cadr instr)))
      ((andwf)
       (andwf (cadr instr)))
      ((iorwf)
       (iorwf (cadr instr)))
      ((xorwf)
       (xorwf (cadr instr)))
      ((rlcf)
       (rlcf (cadr instr)))
      ((rrcf)
       (rrcf (cadr instr)))
      ((bcf)
       (bcf (cadr instr) (caddr instr)))
      ((bsf)
       (bsf (cadr instr) (caddr instr)))
      ((btg)
       (btg (cadr instr) (caddr instr)))
      ((comf)
       (comf (cadr instr)))
      ((cpfseq)
       (cpfseq (cadr instr)))
      ((cpfslt)
       (cpfslt (cadr instr)))
      ((cpfsgt)
       (cpfsgt (cadr instr)))
      ((bra)
       (bra (cadr instr)))
      ((rcall)
       (rcall (cadr instr)))
      ((return)
       (return))
      ((label)
       (asm-listing
        (string-append (symbol->string (asm-label-id (cadr instr))) ":"))
       (asm-label (cadr instr)))
      ((sleep)
       (sleep))
      (else
       (error "unknown instruction" instr))))

  (asm-begin! 0 #f)

                                        ;  (pretty-print cfg)

  (let ((code (linearize-and-cleanup cfg)))
                                        ;    (pretty-print code)
    (for-each gen code)))

(define (code-gen filename cfg)
  (allocate-registers cfg)
  (pp code-generation:)
  (time (assembler-gen filename cfg)))
