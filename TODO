finish parser
add pointers
add main
forward declarations
optimize stuff like : bra $4, 4: (jump to the next line)
eliminate dead code after branches before next label (should be generated at all, surprising, but look at asm from test6, label $5 has a return after a bra $4)


pour avoir comparaison d'egalite avec cste, load cste dans wreg, et CPFSEQ
TODO verifier si je l'ai pas deja ajoute


+= is not supported, so probably neither are his brothers


postinc/dec in an expression does not work (sigma example had res = res + n--, gave the decremented value)

avoir suite de tests (entre autres, tous les types de conditions)

add support for pointer types parsing in six

pour l'instant, faire marcher declarations de tableaux avec taille fixe (i.e. int b[3]), devrait etre assez, su moins pour le moment (ou p-e meme pour picobit au complet)

six.index should behave correctly if used in the lhs of an assignment

simulator does not support byte-to-byte, whatever that is NEEDED FOR MOVFF (avoir movff)

voir si en C, on peut caster de int vers byte, par exemple

faire marcher les < et > sur plusieurs bytes

elimination de tests sur relations avec juste des literaux : 0 > 1

voir si un fonction qui prend un int, a qui on donne un byte marche convenablement
aussi, voir si casts explicites peuvent marcher commedu monde


tableaux
var SIXPIC_MEMORY_DIVIDE : a partir de cette adresse, la memoire est geree par l'usager


see test 21, implicit return at the end cannot return array assignations, so array assignations cannot be the last statement, bug ?




reconnait si on pre/post inc/dec vars speciales FSRx et on utilise POSTINC0 et cie
PICOBIT : ajouter bignums (voir code marc), ca fait une contribution
switchs en tables
compiler picobit petit bout par petit bout pour voir ou on peut ameliorer

binums dans picobit : 0 = 16 bits de 0 et pointeur vers 16 bits de 0, objet qq part en memoire, ca donne suite infinie de 0
-1 est meme chose avec juste des 1, -2 est 111..10 et pointeur vers -1, donc ca fait 0 avec infinite de -1, on arrete algos quand les 2 vals sont a 0 ou -1
p-e avoir un tableau qu ipointe vers -1...10 alloues en permanence, ou p-e avoir 2 espaces de 1 objet pour mettre les operandes en objets d'une primitive, qu'on genere on the fly, voir code marc

p-e autre chose, j'ai le feeling d'avoir oublie de quoi


there is a way to put a var in FSR0, but any regular table access would overwrite it, watch out

if a special FSR var, only SIXPIC_FSRX[0] makes any sense, since the address should already be good
use simple dereference (*) syntax instead, to avoir confusion

SYNTAX DE DEREF MARCHE DANS SIX, utiliser

simplifier assignation sur dereference pour utiliser nouvelle version de array-base-name quand array-ref va etre un operateur, pas un cas particulier de syntaxe
merger les 2 syntaxes


BUG : si on fait SIXPIC_FSR0 = SIXPIC_MEMORY_DIVIDE;, allocation de registres doit merger les 2, et FSR est pas stocke dans FSR, donc on perd le benefices, corriger
p-e, pour regler ca, mettre un flag sur les values pour dire si elle doit etre allouee dans un registre ou non ?


de test26, la VM
			$4:
000092 E150		    movf    FSR1L, w
000094 016E		    movwf   1
000096 012A		    incf    1
000098 E250		    movf    FSR1H, w
assez insultant

encore de la vm
			$12:
0000AA D950		    movf    FSR2L, w
0000AC 016E		    movwf   1
0000AE 012A		    incf    1
0000B0 DA50		    movf    FSR2H, w
0000B2 026E		    movwf   2
0000B4 000E		    movlw   0
0000B6 0222		    addwfc  2
0000B8 0150		    movf    1, w
0000BA E96E		    movwf   FSR0L
0000BC 0250		    movf    2, w
0000BE EA6E		    movwf   FSR0H
pas super, on pourrait tranferer le resultat au fur et a mesure qu'il est calcule, on sauverait des voyages par w
